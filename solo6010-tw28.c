/*
 * Copyright (C) 2010 Ben Collins <bcollins@bluecherry.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <linux/kernel.h>

#include "solo6010-tw28.h"
#include "solo6010-i2c.h"

/* XXX: Some of these values are masked into an 8-bit regs, and shifted
 * around for other 8-bit regs. What are the magic bits in these values? */
#define DEFAULT_HDELAY_NTSC		(32 - 4)
#define DEFAULT_HACTIVE_NTSC		(720 + 16)
#define DEFAULT_VDELAY_NTSC		(7 - 2)
#define DEFAULT_VACTIVE_NTSC		(240 + 4)

#define DEFAULT_HDELAY_PAL		(32 + 4)
#define DEFAULT_HACTIVE_PAL		(864-DEFAULT_HDELAY_PAL)
#define DEFAULT_VDELAY_PAL		(6)
#define DEFAULT_VACTIVE_PAL		(312-DEFAULT_VDELAY_PAL)

static u8 tbl_ntsc_tw2865_common[] = {
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x02,
	0x12, 0xff, 0x09, 0xd0, 0x00, 0x00, 0x00, 0x7f,
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x02,
	0x12, 0xff, 0x09, 0xd0, 0x00, 0x00, 0x00, 0x7f,
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x02,
	0x12, 0xff, 0x09, 0xd0, 0x00, 0x00, 0x00, 0x7f,
	0x00, 0xd4, 0x70, 0x48, 0x80, 0x80, 0x00, 0x02,
	0x12, 0xff, 0x09, 0xd0, 0x00, 0x00, 0x00, 0x7f,
	0x00, 0x00, 0x90, 0x68, 0x00, 0x38, 0x80, 0x80,
	0x80, 0x80, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x45, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x21, 0x43,
	0x08, 0x00, 0x00, 0x01, 0xf1, 0x03, 0xEF, 0x03,
	0xE9, 0x03, 0xD9, 0x15, 0x15, 0xE4, 0xA3, 0x80,
	0x00, 0x02, 0x00, 0xCC, 0x00, 0x80, 0x44, 0x50,
	0x22, 0x01, 0xD8, 0xBC, 0xB8, 0x44, 0x38, 0x00,
	0x00, 0x78, 0x44, 0x3D, 0x14, 0xA5, 0xE0, 0x05,
	0x00, 0x28, 0x44, 0x44, 0xA0, 0x90, 0x52, 0x00,
	0x08, 0x08, 0x08, 0x08, 0x1A, 0x1A, 0x1B, 0x1A,
	0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0x44,
	0x44, 0x4A, 0x00, 0xFF, 0xEF, 0xEF, 0xEF, 0xEF,
	0xFF, 0xE7, 0xE9, 0xE9, 0xEB, 0xFF, 0xD6, 0xD8,
	0xD8, 0xD7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xE4, 0x39, 0x00, 0x80,
	0xA8, 0x88, 0x01, 0x10, 0x32, 0x10, 0x32, 0x10,
	0x32, 0x10, 0x32, 0xC1, 0x00, 0x00, 0x00, 0x80,
	0x14, 0xC0, 0xAA, 0xAA, 0x00, 0x11, 0x00, 0x00,
	0x11, 0x00, 0x00, 0x11, 0x00, 0x00, 0x11, 0x00,
	0x83, 0xB5, 0x09, 0x78, 0x85, 0x00, 0x01, 0x20,
	0xC4, 0x51, 0x40, 0x2F, 0xFF, 0xF0, 0x00, 0xC0,
};

static u8 tbl_pal_tw2865_common[] = {
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x12,
	0x11, 0xff, 0x01, 0xc3, 0x00, 0x00, 0x01, 0x7f,
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x12,
	0x11, 0xff, 0x01, 0xc3, 0x00, 0x00, 0x01, 0x7f,
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x12,
	0x11, 0xff, 0x01, 0xc3, 0x00, 0x00, 0x01, 0x7f,
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x12,
	0x11, 0xff, 0x01, 0xc3, 0x00, 0x00, 0x01, 0x7f,
	0x00, 0x94, 0x90, 0x48, 0x00, 0x38, 0x7F, 0x80,
	0x80, 0x80, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x15, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x21, 0x43,
	0x08, 0x00, 0x00, 0x01, 0xf1, 0x03, 0xEF, 0x03,
	0xEA, 0x03, 0xD9, 0x15, 0x15, 0xE4, 0xA3, 0x80,
	0x00, 0x02, 0x00, 0xCC, 0x00, 0x80, 0x44, 0x50,
	0x22, 0x01, 0xD8, 0xBC, 0xB8, 0x44, 0x38, 0x00,
	0x00, 0x78, 0x44, 0x3D, 0x14, 0xA5, 0xE0, 0x05,
	0x00, 0x28, 0x44, 0x44, 0xA0, 0x90, 0x52, 0x00,
	0x08, 0x08, 0x08, 0x08, 0x1A, 0x1A, 0x1A, 0x1A,
	0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0x44,
	0x44, 0x4A, 0x00, 0xFF, 0xEF, 0xEF, 0xEF, 0xEF,
	0xFF, 0xE7, 0xE9, 0xE9, 0xE9, 0xFF, 0xD7, 0xD8,
	0xD9, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xE4, 0x39, 0x00, 0x80,
	0x88, 0x88, 0x01, 0x10, 0x32, 0x10, 0x32, 0x10,
	0x32, 0x10, 0x32, 0xC1, 0x00, 0x00, 0x00, 0x80,
	0x14, 0xC0, 0xAA, 0xAA, 0x00, 0x11, 0x00, 0x00,
	0x11, 0x00, 0x00, 0x11, 0x00, 0x00, 0x11, 0x00,
	0x83, 0xB5, 0x09, 0x00, 0xA0, 0x00, 0x01, 0x20,
	0xC4, 0x51, 0x40, 0x2F, 0xFF, 0xF0, 0x00, 0xC0,
};

static u8 tbl_ntsc_tw2864_common[] = {
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x02,
	0x12, 0xf5, 0x09, 0xd0, 0x00, 0x00, 0x00, 0x7f,
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x02,
	0x12, 0xf5, 0x09, 0xd0, 0x00, 0x00, 0x00, 0x7f,
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x02,
	0x12, 0xf5, 0x09, 0xd0, 0x00, 0x00, 0x00, 0x7f,
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x02,
	0x12, 0xf5, 0x09, 0xd0, 0x00, 0x00, 0x00, 0x7f,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA3, 0x00,
	0x00, 0x02, 0x00, 0xcc, 0x00, 0x80, 0x44, 0x50,
	0x22, 0x01, 0xd8, 0xbc, 0xb8, 0x44, 0x38, 0x00,
	0x00, 0x78, 0x72, 0x3e, 0x14, 0xa5, 0xe4, 0x05,
	0x00, 0x28, 0x44, 0x44, 0xa0, 0x88, 0x5a, 0x00,
	0x08, 0x08, 0x08, 0x08, 0x1a, 0x1a, 0x1a, 0x1a,
	0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0, 0x44,
	0x44, 0x0a, 0x00, 0xff, 0xef, 0xef, 0xef, 0xef,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xb1, 0xe4, 0x40, 0x00,
	0x77, 0x77, 0x01, 0x10, 0x32, 0x54, 0x76, 0x98,
	0xba, 0xdc, 0xfe, 0xc1, 0x00, 0x00, 0x00, 0x80,
	0x00, 0xe0, 0xbb, 0xbb, 0x00, 0x11, 0x00, 0x00,
	0x11, 0x00, 0x00, 0x11, 0x00, 0x00, 0x11, 0x00,
	0x83, 0xb5, 0x09, 0x78, 0x85, 0x00, 0x01, 0x20,
	0x64, 0x11, 0x40, 0x0f, 0xff, 0x00, 0x00, 0x00,
};

static u8 tbl_pal_tw2864_common[] = {
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x12,
	0x18, 0xf5, 0x01, 0xc3, 0x00, 0x00, 0x01, 0x7f,
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x12,
	0x18, 0xf5, 0x01, 0xc3, 0x00, 0x00, 0x01, 0x7f,
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x12,
	0x18, 0xf5, 0x01, 0xc3, 0x00, 0x00, 0x01, 0x7f,
	0x00, 0xd4, 0x70, 0x30, 0x80, 0x80, 0x00, 0x12,
	0x18, 0xf5, 0x01, 0xc3, 0x00, 0x00, 0x01, 0x7f,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA3, 0x00,
	0x00, 0x02, 0x00, 0xcc, 0x00, 0x80, 0x44, 0x50,
	0x22, 0x01, 0xd8, 0xbc, 0xb8, 0x44, 0x38, 0x00,
	0x00, 0x78, 0x72, 0x3e, 0x14, 0xa5, 0xe4, 0x05,
	0x00, 0x28, 0x44, 0x44, 0xa0, 0x90, 0x5a, 0x01,
	0x08, 0x08, 0x08, 0x08, 0x1a, 0x1a, 0x1a, 0x1a,
	0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0, 0x44,
	0x44, 0x0a, 0x00, 0xff, 0xef, 0xef, 0xef, 0xef,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xb1, 0xe4, 0x40, 0x00,
	0x77, 0x77, 0x01, 0x10, 0x32, 0x54, 0x76, 0x98,
	0xba, 0xdc, 0xfe, 0xc1, 0x00, 0x00, 0x00, 0x80,
	0x00, 0xe0, 0xbb, 0xbb, 0x00, 0x11, 0x00, 0x00,
	0x11, 0x00, 0x00, 0x11, 0x00, 0x00, 0x11, 0x00,
	0x83, 0xb5, 0x09, 0x00, 0xa0, 0x00, 0x01, 0x20,
	0x64, 0x11, 0x40, 0x0f, 0xff, 0x00, 0x00, 0x00,
};

#define is_tw2868x(__solo, __id) \
	((__solo->tw2865 & (1 << __id)) || (__solo->tw2864 & (1 << __id)))

#if 0
static u8 tw_readbyte(struct solo6010_dev *solo_dev, int chip_id, u8 tw68x_off,
		      u8 tw_off)
{
	if (is_tw2868x(solo_dev, chip_id))
		return solo_i2c_readbyte(solo_dev, SOLO_I2C_TW,
					     TW_CHIP_OFFSET_ADDR(chip_id),
					     tw68x_off);
	else
		return solo_i2c_readbyte(solo_dev, SOLO_I2C_TW,
					     TW_CHIP_OFFSET_ADDR(chip_id),
					     tw_off);
}

static void tw_writebyte(struct solo6010_dev *solo_dev, int chip_id,
			 u8 tw68x_off, u8 tw_off, u8 val)
{
	if (is_tw2868x(solo_dev, chip_id))
		solo_i2c_writebyte(solo_dev, SOLO_I2C_TW,
				       TW_CHIP_OFFSET_ADDR(chip_id),
				       tw68x_off, val);
	else
		solo_i2c_writebyte(solo_dev, SOLO_I2C_TW,
				      TW_CHIP_OFFSET_ADDR(chip_id),
				      tw_off, val);
}
#endif

static void tw_write_and_verify(struct solo6010_dev *solo_dev, u8 addr, u8 off,
				u8 val)
{
	int i;
	u8 rval;

	for (i = 0; i < 4; i++) {
		solo_i2c_writebyte(solo_dev, SOLO_I2C_TW, addr,
				       off, val);
		msleep_interruptible(1);
		rval = solo_i2c_readbyte(solo_dev, SOLO_I2C_TW,
					     addr, off);

		if (rval == val)
			break;
	}

	if (rval != val)
		printk_once("solo6010/tw28: Error writing registers\n");
}


static int tw2865_setup(struct solo6010_dev *solo_dev, u8 dev_addr)
{
	u8 tbl_tw2865_common[256];
	int i;

	if (solo_dev->vout_type == SOLO_VO_FMT_TYPE_NTSC)
		memcpy(tbl_tw2865_common, tbl_ntsc_tw2865_common,
		       sizeof(tbl_tw2865_common));
	else
		memcpy(tbl_tw2865_common, tbl_pal_tw2865_common,
		       sizeof(tbl_tw2865_common));

	/* XXX: Here's a stupid question: Why do we change this here instead
	 * making it the default in the static tables? */

	/* 54MHz input, PLL mode select */
	tbl_tw2865_common[0x60] = 0x45;
	tbl_tw2865_common[0x61] = 0x11;

	/* ITU.BT656 27MHz ouput signale with rise/fall timing */
	tbl_tw2865_common[0x82] = 0x00;
	tbl_tw2865_common[0x9f] = 0x13;
	tbl_tw2865_common[0x67] = 0x00;
	tbl_tw2865_common[0x68] = 0x00;
	tbl_tw2865_common[0x69] = 0x00;
	tbl_tw2865_common[0xca] = 0x55;
	/* Clock PIN's 1-4 control */
	tbl_tw2865_common[0xfa] = 0x40;
	tbl_tw2865_common[0x6a] = 0x00;
	tbl_tw2865_common[0x6b] = 0x00;
	tbl_tw2865_common[0x6c] = 0x00;
	/* Clock polarity control */
	tbl_tw2865_common[0xfb] = 0xaf;
	tbl_tw2865_common[0x6d] = 0x00;

	/* Audio sampling frequency, 0x08 == 8KHz, 0x09 == 16KHz */
	tbl_tw2865_common[0x70] = 0x08;

	/* Audio settings */
	tbl_tw2865_common[0xd0] = 0x77;
	tbl_tw2865_common[0xd1] = 0x77;
	tbl_tw2865_common[0xd2] = 0x03;

	tbl_tw2865_common[0xd3] = 0x20;
	tbl_tw2865_common[0xd4] = 0x57;
	tbl_tw2865_common[0xd5] = 0x9b;
	tbl_tw2865_common[0xd6] = 0xdf;
	tbl_tw2865_common[0xd7] = 0x31;
	tbl_tw2865_common[0xd8] = 0x64;
	tbl_tw2865_common[0xd9] = 0xa8;
	tbl_tw2865_common[0xda] = 0xec;

	tbl_tw2865_common[0xdb] = 0xd1;
	tbl_tw2865_common[0xdc] = 0x10;
	tbl_tw2865_common[0xdd] = 0x11;
	tbl_tw2865_common[0xde] = 0x11;
	tbl_tw2865_common[0xdf] = 0x81;
	tbl_tw2865_common[0xe0] = 0x10;
	tbl_tw2865_common[0xf8] = 0x64;

	tbl_tw2865_common[0xdb] = 0xd1;
	tbl_tw2865_common[0xdc] = 0x0f;
	tbl_tw2865_common[0xdd] = 0x11;
	tbl_tw2865_common[0xde] = 0x11;
	tbl_tw2865_common[0xdf] = 0x81;
	tbl_tw2865_common[0xe0] = 0x10;
	tbl_tw2865_common[0xf8] = 0x64;

	/* Setup the audio cascade, ALINK Mode */
	if (solo_dev->nr_chans == 4) {
		tbl_tw2865_common[0xd2] = 0x01;
		tbl_tw2865_common[0xcf] = 0x00;
	} else if (solo_dev->nr_chans == 8) {
		tbl_tw2865_common[0xd2] = 0x02;
		if (dev_addr == 0x28 + 1)
			tbl_tw2865_common[0xcf] = 0x80;
	} else if (solo_dev->nr_chans == 16) {
		tbl_tw2865_common[0xd2] = 0x03;
		if (dev_addr == 0x28 + 1)
			tbl_tw2865_common[0xcf] = 0x83;
		else if (dev_addr == 0x28 + 2)
			tbl_tw2865_common[0xcf] = 0x83;
		else if (dev_addr == 0x28 + 3)
			tbl_tw2865_common[0xcf] = 0x80;
	}

	/* Write out the registers */
	for (i = 0; i <= 0xff; i++) {
		/* Skip read only registers */
		if (i == 0x00 || i == 0x10 || i == 0x20 || i == 0x30 ||
		    i == 0x0c || i == 0x1c || i == 0x2c || i == 0x3c ||
		    i == 0x0d || i == 0x1d || i == 0x2d || i == 0x3d ||
		    i == 0xb8 || i == 0xb9 || i == 0xba || i == 0xbb ||
		    i == 0xbc || i == 0xbd || i == 0xbe || i == 0xbf ||
		    i == 0xc0 || i == 0xc1 || i == 0xc4 || i == 0xc5 ||
		    i == 0xc6 || i == 0xc7 || i == 0xfd)
			continue;

		tw_write_and_verify(solo_dev, dev_addr, i,
				    tbl_tw2865_common[i]);
	}

	return 0;
}

static int tw2864_setup(struct solo6010_dev *solo_dev, u8 dev_addr)
{
	u8 tbl_tw2864_common[256];
	int i;
	int reg;

	if (solo_dev->vout_type == SOLO_VO_FMT_TYPE_NTSC)
		memcpy(tbl_tw2864_common, tbl_ntsc_tw2864_common,
		       sizeof(tbl_tw2864_common));
	else
		memcpy(tbl_tw2864_common, tbl_pal_tw2864_common,
		       sizeof(tbl_tw2864_common));

	if (solo_dev->tw2865 != 0) {
		for (i = 0; i <= 4; i++) {
			reg = (0x08 | i << 4);
			tbl_tw2864_common[reg] = 0x12;
		}
	}

	/*  Video Settings, 27MHz */
	tbl_tw2864_common[0x82] = 0x00;
	tbl_tw2864_common[0x9f] = 0x01;
	tbl_tw2864_common[0xca] = 0x55;
	tbl_tw2864_common[0xfa] = 0x40;
	tbl_tw2864_common[0xfb] = 0xaf;

	/* Audio Settings */
	if (solo_dev->vout_type == SOLO_VO_FMT_TYPE_NTSC) {
		tbl_tw2864_common[0xf0] = 0x83;
		tbl_tw2864_common[0xf1] = 0xb5;
		tbl_tw2864_common[0xf2] = 0x09;
		tbl_tw2864_common[0xf3] = 0x78;
		tbl_tw2864_common[0xf4] = 0x85;
		tbl_tw2864_common[0xf5] = 0x00;
	} else {
		tbl_tw2864_common[0xf0] = 0x83;
		tbl_tw2864_common[0xf1] = 0xb5;
		tbl_tw2864_common[0xf2] = 0x09;
		tbl_tw2864_common[0xf3] = 0x00;
		tbl_tw2864_common[0xf4] = 0xa0;
		tbl_tw2864_common[0xf5] = 0x00;
	}

	/* Audio settings */
	tbl_tw2864_common[0xd0] = 0x77;
	tbl_tw2864_common[0xd1] = 0x77;

	tbl_tw2864_common[0xd3] = 0x13;
	tbl_tw2864_common[0xd4] = 0x57;
	tbl_tw2864_common[0xd5] = 0x9b;
	tbl_tw2864_common[0xd6] = 0xdf;
	tbl_tw2864_common[0xd7] = 0x20;
	tbl_tw2864_common[0xd8] = 0x64;
	tbl_tw2864_common[0xd9] = 0xa8;
	tbl_tw2864_common[0xda] = 0xec;

	tbl_tw2864_common[0xdb] = 0xd1;
	tbl_tw2864_common[0xdc] = 0x0f;
	tbl_tw2864_common[0xdd] = 0x11;
	tbl_tw2864_common[0xde] = 0x11;
	tbl_tw2864_common[0xdf] = 0x81;
	tbl_tw2864_common[0xe0] = 0x10;
	tbl_tw2864_common[0xf8] = 0x64;

	/* Setup the audio cascade */
	if (solo_dev->tw2865 == 0) {
		/* IRQ Mode */
		if (solo_dev->nr_chans == 4) {
			tbl_tw2864_common[0xd2] = 0x01;
			tbl_tw2864_common[0xcf] = 0x00;
		} else if (solo_dev->nr_chans == 8) {
			tbl_tw2864_common[0xd2] = 0x02;
			if (dev_addr == 0x28 + 0)
				tbl_tw2864_common[0xcf] = 0x43;
			else if (dev_addr == 0x28 + 1)
				tbl_tw2864_common[0xcf] = 0x40;
		} else if (solo_dev->nr_chans == 16) {
			tbl_tw2864_common[0xd2] = 0x03;
			if (dev_addr == 0x28 + 0)
				tbl_tw2864_common[0xcf] = 0x43;
			else if (dev_addr == 0x28 + 1)
				tbl_tw2864_common[0xcf] = 0x43;
			else if (dev_addr == 0x28 + 2)
				tbl_tw2864_common[0xcf] = 0x43;
			else if (dev_addr == 0x28 + 3)
				tbl_tw2864_common[0xcf] = 0x40;
		}
	} else {
		/* ALINK Mode */
		if (solo_dev->nr_chans == 8) {
			tbl_tw2864_common[0xd2] = 0x02;
			if (dev_addr == 0x28 + 1)
				tbl_tw2864_common[0xcf] = 0x80;
		} else if (solo_dev->nr_chans == 16) {
			tbl_tw2864_common[0xd2] = 0x03;
			if (dev_addr == 0x28 + 1)
				tbl_tw2864_common[0xcf] = 0x83;
			else if (dev_addr == 0x28 + 2)
				tbl_tw2864_common[0xcf] = 0x83;
			else if (dev_addr == 0x28 + 3)
				tbl_tw2864_common[0xcf] = 0x80;
		}
	}

	for (i = 0; i < 0xff; i++) {
		/* Skip read only registers */
		if (i == 0x00 || i == 0x10 || i == 0x20 || i == 0x30 ||
		    i == 0x0c || i == 0x1c || i == 0x2c || i == 0x3c ||
		    i == 0x0d || i == 0x1d || i == 0x2d || i == 0x3d ||
		    i == 0xb8 || i == 0xb9 || i == 0xba || i == 0xbb ||
		    i == 0xbc || i == 0xbd || i == 0xbe || i == 0xbf ||
		    i == 0xc0 || i == 0xc1 || i == 0xfd)
			continue;

		tw_write_and_verify(solo_dev, dev_addr, i,
				    tbl_tw2864_common[i]);
	}

	return 0;
}

static int tw2815_setup(struct solo6010_dev *solo_dev, u8 dev_addr)
{
	u8 tbl_ntsc_tw2815_common[] = {
		0x00, 0xc8, 0x20, 0xd0, 0x06, 0xf0, 0x08, 0x80,
		0x80, 0x80, 0x80, 0x02, 0x06, 0x00, 0x11,
	};

	u8 tbl_pal_tw2815_common[] = {
		0x00, 0x88, 0x20, 0xd0, 0x05, 0x20, 0x28, 0x80,
		0x80, 0x80, 0x80, 0x82, 0x06, 0x00, 0x11,
	};

	u8 tbl_tw2815_sfr[] = {
		0x00, 0x00, 0x00, 0xc0, 0x45, 0xa0, 0xd0, 0x2f,
		0x64, 0x80, 0x80, 0x82, 0x82, 0x80, 0x00, 0x00,
		0x00, 0x0f, 0x05, 0x00, 0x00, 0x80, 0x06, 0x00,
		0x00, 0x00, 0x00, 0xff, 0x8f, 0x00, 0x00, 0x00,
		0x88, 0x88, 0xc0, 0x00, 0x10, 0x32, 0x54, 0x76,
		0x98, 0xba, 0xdc, 0xfe, 0x00, 0x00, 0x88, 0x88,
		0x88, 0x11, 0x00, 0x88, 0x88, 0x00,
	};
	u8 *tbl_tw2815_common;
	int i;
	int ch;

	tbl_ntsc_tw2815_common[0x06] = 0;

	/* Horizontal Delay Control */
	tbl_ntsc_tw2815_common[0x02] = DEFAULT_HDELAY_NTSC;
	tbl_ntsc_tw2815_common[0x06] |= 0x03 & (DEFAULT_HDELAY_NTSC >> 8);

	/* Horizontal Active Control */
	tbl_ntsc_tw2815_common[0x03] = DEFAULT_HACTIVE_NTSC & 0xff;
	tbl_ntsc_tw2815_common[0x06] |=
		((0x03 & (DEFAULT_HACTIVE_NTSC >> 8)) << 2);

	/* Vertical Delay Control */
	tbl_ntsc_tw2815_common[0x04] = DEFAULT_VDELAY_NTSC;
	tbl_ntsc_tw2815_common[0x06] |=
		((0x01 & (DEFAULT_VDELAY_NTSC >> 8)) << 4);

	/* Vertical Active Control */
	tbl_ntsc_tw2815_common[0x05] = DEFAULT_VACTIVE_NTSC;
	tbl_ntsc_tw2815_common[0x06] |=
		((0x01 & (DEFAULT_VACTIVE_NTSC >> 8)) << 5);

	tbl_pal_tw2815_common[0x06] = 0;

	/* Horizontal Delay Control */
	tbl_pal_tw2815_common[0x02] = DEFAULT_HDELAY_PAL;
	tbl_pal_tw2815_common[0x06] |= 0x03 & (DEFAULT_HDELAY_PAL >> 8);

	/* Horizontal Active Control */
	tbl_pal_tw2815_common[0x03] = DEFAULT_HACTIVE_PAL & 0xff;
	tbl_pal_tw2815_common[0x06] |=
		((0x03 & (DEFAULT_HACTIVE_PAL >> 8)) << 2);

	/* Vertical Delay Control */
	tbl_pal_tw2815_common[0x04] = DEFAULT_VDELAY_PAL;
	tbl_pal_tw2815_common[0x06] |=
		((0x01 & (DEFAULT_VDELAY_PAL >> 8)) << 4);

	/* Vertical Active Control */
	tbl_pal_tw2815_common[0x05] = DEFAULT_VACTIVE_PAL & 0xff;
	tbl_pal_tw2815_common[0x06] |=
		((0x01 & (DEFAULT_VACTIVE_PAL >> 8)) << 5);

	tbl_tw2815_common =
	    (solo_dev->vout_type == SOLO_VO_FMT_TYPE_NTSC) ?
	     tbl_ntsc_tw2815_common : tbl_pal_tw2815_common;

	/* Dual ITU-R BT.656 format */
	tbl_tw2815_common[0x0d] |= 1 << 2;
	/* Clock delay */
	tbl_tw2815_sfr[0x4d - 0x40] = 0x00;

	/* Audio configuration */
	tbl_tw2815_sfr[0x62 - 0x40] &= ~(3 << 6);

	if (solo_dev->nr_chans == 4) {
		tbl_tw2815_sfr[0x63 - 0x40] |= 1;
		tbl_tw2815_sfr[0x62 - 0x40] |= 3 << 6;
	} else if (solo_dev->nr_chans == 8) {
		tbl_tw2815_sfr[0x63 - 0x40] |= 2;
		if (dev_addr == 0x28 + 0)
			tbl_tw2815_sfr[0x62 - 0x40] |= 1 << 6;
		else if (dev_addr == 0x28 + 1)
			tbl_tw2815_sfr[0x62 - 0x40] |= 2 << 6;
	} else if (solo_dev->nr_chans == 16) {
		tbl_tw2815_sfr[0x63 - 0x40] |= 3;
		if (dev_addr == 0x28 + 0)
			tbl_tw2815_sfr[0x62 - 0x40] |= 1 << 6;
		else if (dev_addr == 0x28 + 1)
			tbl_tw2815_sfr[0x62 - 0x40] |= 0 << 6;
		else if (dev_addr == 0x28 + 2)
			tbl_tw2815_sfr[0x62 - 0x40] |= 0 << 6;
		else if (dev_addr == 0x28 + 3)
			tbl_tw2815_sfr[0x62 - 0x40] |= 2 << 6;
	}

	/* SOLO6010 compatible R_SEQ_0 ~ R_SEQ_F */
	tbl_tw2815_sfr[0x64 - 0x40] = 0x20;	// 0010 0000  -  2  0
	tbl_tw2815_sfr[0x65 - 0x40] = 0x64;	// 0110 0100  -  6  4
	tbl_tw2815_sfr[0x66 - 0x40] = 0xa8;	// 1010 1000  - 10  8
	tbl_tw2815_sfr[0x67 - 0x40] = 0xec;	// 1110 1100  - 14 12
	tbl_tw2815_sfr[0x68 - 0x40] = 0x31;	// 0011 0001  -  3  1
	tbl_tw2815_sfr[0x69 - 0x40] = 0x75;	// 0111 0101  -  7  5
	tbl_tw2815_sfr[0x6a - 0x40] = 0xb9;	// 1011 1001  - 11  9
	tbl_tw2815_sfr[0x6b - 0x40] = 0xfd;	// 1111 1101  - 15 13

	/* Output mode of R_ADATM pin (0 mixing, 1 record) */
	/* tbl_tw2815_sfr[0x63 - 0x40] |= 0 << 2; */

	/* 8KHz, used to be 16KHz, but changed for remote client compat */
	tbl_tw2815_sfr[0x62 - 0x40] |= 0 << 2;
	tbl_tw2815_sfr[0x6c - 0x40] |= 0 << 2;

	/* Playback of right channel */
	tbl_tw2815_sfr[0x6c - 0x40] |= 1 << 5;

	/* Reserved value (XXX ??) */
	tbl_tw2815_sfr[0x5c - 0x40] |= 1 << 5;

	/* Analog output gain and mix ratio playback on full */
	tbl_tw2815_sfr[0x70 - 0x40] |= 0xff;
	/* Select playback audio and mute all except */
	tbl_tw2815_sfr[0x71 - 0x40] |= 0x10;
	tbl_tw2815_sfr[0x6d - 0x40] |= 0x0f;

	/* End of audio configuration */

	for (ch = 0; ch < 4; ch++) {
		tbl_tw2815_common[0x0d] &= ~3;
		if (ch == 0)
			tbl_tw2815_common[0x0d] |= 0x21;
		if (ch == 1)
			tbl_tw2815_common[0x0d] |= 0x20;
		if (ch == 2)
			tbl_tw2815_common[0x0d] |= 0x23;
		if (ch == 3)
			tbl_tw2815_common[0x0d] |= 0x22;

		for (i = 0; i < 0x0f; i++) {
			if (i == 0x00)
				continue;	// read-only
			solo_i2c_writebyte(solo_dev, SOLO_I2C_TW,
					       dev_addr, (ch * 0x10) + i,
					       tbl_tw2815_common[i]);
		}
	}

	for (i = 0x40; i < 0x76; i++) {
		/* Skip read-only and nop registers */
		if (i == 0x40 || i == 0x59 || i == 0x5A ||
		    i == 0x5d || i == 0x5e || i == 0x5f)
			continue;

		solo_i2c_writebyte(solo_dev, SOLO_I2C_TW, dev_addr, i,
				       tbl_tw2815_sfr[i - 0x40]);
	}

	return 0;
}

#define FIRST_ACTIVE_LINE	0x0008
#define LAST_ACTIVE_LINE	0x0102

static void saa7128_setup(struct solo6010_dev *solo_dev)
{
	int i;
	unsigned char regs[128] = {
		0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1C, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00,
		0x59, 0x1d, 0x75, 0x3f, 0x06, 0x3f, 0x00, 0x00,
		0x1c, 0x33, 0x00, 0x3f, 0x00, 0x00, 0x3f, 0x00,
		0x1a, 0x1a, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x68, 0x10, 0x97, 0x4c, 0x18,
		0x9b, 0x93, 0x9f, 0xff, 0x7c, 0x34, 0x3f, 0x3f,
		0x3f, 0x83, 0x83, 0x80, 0x0d, 0x0f, 0xc3, 0x06,
		0x02, 0x80, 0x71, 0x77, 0xa7, 0x67, 0x66, 0x2e,
		0x7b, 0x11, 0x4f, 0x1f, 0x7c, 0xf0, 0x21, 0x77,
		0x41, 0x88, 0x41, 0x12, 0xed, 0x10, 0x10, 0x00,
		0x41, 0xc3, 0x00, 0x3e, 0xb8, 0x02, 0x00, 0x00,
		0x00, 0x00, 0x08, 0xff, 0x80, 0x00, 0xff, 0xff,
	};

	regs[0x7A] = FIRST_ACTIVE_LINE & 0xff;
	regs[0x7B] = LAST_ACTIVE_LINE & 0xff;
	regs[0x7C] = ((1 << 7) |
			(((LAST_ACTIVE_LINE >> 8) & 1) << 6) |
			(((FIRST_ACTIVE_LINE >> 8) & 1) << 4));

	/* PAL: XXX: We could do a second set of regs to avoid this */
	if (solo_dev->vout_type != SOLO_VO_FMT_TYPE_NTSC) {
		regs[0x28] = 0xE1;

		regs[0x5A] = 0x0F;
		regs[0x61] = 0x02;
		regs[0x62] = 0x35;
		regs[0x63] = 0xCB;
		regs[0x64] = 0x8A;
		regs[0x65] = 0x09;
		regs[0x66] = 0x2A;

		regs[0x6C] = 0xf1;
		regs[0x6E] = 0x20;

		regs[0x7A] = 0x06 + 12;
		regs[0x7b] = 0x24 + 12;
		regs[0x7c] |= 1 << 6;
	}

	/* First 0x25 bytes are read-only? */
	for (i = 0x26; i < 128; i++) {
		if (i == 0x60 || i == 0x7D)
			continue;
		solo_i2c_writebyte(solo_dev, SOLO_I2C_SAA, 0x46, i, regs[i]);
	}

	return;
}

int solo_tw28_init(struct solo6010_dev *solo_dev)
{
	int i;
	u8 value;

	/* Detect techwell chip type */
	for (i = 0; i < TW_NUM_CHIP; i++) {
		value = solo_i2c_readbyte(solo_dev, SOLO_I2C_TW,
					  TW_CHIP_OFFSET_ADDR(i), 0xFF);
		if ((value >> 3) == 0x18) {
			solo_dev->tw2865 |= 1 << i;
			solo_dev->tw28_cnt++;
		} else if ((value >> 3) == 0x0C) {
			solo_dev->tw2864 |= 1 << i;
			solo_dev->tw28_cnt++;
		} else {
			value = solo_i2c_readbyte(solo_dev, SOLO_I2C_TW,
						  TW_CHIP_OFFSET_ADDR(i), 0x59);
			if ((value >> 3) == 0x04)
				solo_dev->tw28_cnt++;
		}
	}

	if (!solo_dev->tw2865 && solo_dev->tw28_cnt)
		saa7128_setup(solo_dev);

	for (i = 0; i < solo_dev->tw28_cnt; i++) {
		if ((solo_dev->tw2865 & (1 << i)))
			tw2865_setup(solo_dev, TW_CHIP_OFFSET_ADDR(i));
		else if ((solo_dev->tw2864 & (1 << i)))
			tw2864_setup(solo_dev, TW_CHIP_OFFSET_ADDR(i));
		else
			tw2815_setup(solo_dev, TW_CHIP_OFFSET_ADDR(i));
	}

	dev_info(&solo_dev->pdev->dev, "Initialized %d tw28xx chips\n",
		 solo_dev->tw28_cnt);

	return 0;
}

#if 0
/* 
 * XXX: We accessed the video status signal in the Techwell chip through
 * iic/i2c because the video status reported by register REG_VI_STATUS1
 * (address 0x012C) of the SOLO6010 chip doesn't give the correct video
 * status signal values. But take note that there are 4 techwell chip in
 * solo6010. Each techwell chip handles 4 video channels. The base address
 * of the techwell chip is 0x28. We can access the 4 techwell chip through
 * the base address and an offset starting from 0 (i.e. 0-3 to access all 4,
 * that is 0x28+0, 0x28+1, ox28+2, 0x28+3). The 4-channel video status we
 * read in each techwell chip is set on the lower 4-bits. Also bit 0 means
 * signal loss for the corresponding channel, bit 1 means signal gain.
 */
unsigned int tw2815_get_video_status(struct solo6010_dev *solo_dev)
{
	unsigned int status = 0x0;
	unsigned int i = 0;

	/* Read the video signal status for the channels in the i-th
         * techwell chip */
	for (i = 0; i < solo_dev->tw28_cnt; i++)
		status |= tw_readbyte(solo_dev, i, TW286X_AV_STAT_ADDR,
				      TW_AV_STAT_ADDR);

	/* 
	 * NOTE: The LX Server applications treats 0 as there is video
	 * signal while 1 is no video signal. For now we revert its value
	 * to minimize modifications in LX applications.
	 */
	status = ~(status & 0xffff);

	return status;
}

/* Status of audio from up to 4 techwell chips are combined into 1 variable.
 * See techwell datasheet for details. */
unsigned int tw2815_get_audio_status(struct solo6010_dev *solo_dev)
{
	unsigned int val;
	unsigned int status = 0x0;
	unsigned int i = 0;

	for (i = 0; i < TW_NUM_CHIP; ++i) {
		val = tw_readbyte(solo_dev, i, TW286X_AV_STAT_ADDR,
				  TW_AV_STAT_ADDR);

		status |= ((val & 0xf0) >> 4) << (i * TW_NUMCHANNEL_PERCHIP);
	}

	status = ~(status & 0xffff);
	return status;
}

void tw2815_Set_ColorComponentValue(struct solo6010_dev *solo_dev,
				    unsigned int color_comp,
				    unsigned int channel,
				    unsigned int u_val)
{
	unsigned int chip_num;

	/* Determine which techwell chip number this channel belongs to. */
	chip_num = (channel / 4);
	/* Determine the corresponding channel for this techwell chip. */
	channel = channel % 4;

	switch (color_comp) {
	case TW_COLOR_HUE:
		if (is_tw2868x(solo_dev, chip_num)) {
			if (u_val >= 125)
				u_val -= 125;
			else
				u_val += 125;
		}
		tw_writebyte(solo_dev, chip_num, TW286x_HUE_ADDR(channel),
			     TW_HUE_ADDR(channel), u_val);

		break;

	case TW_COLOR_SATURATION:
		if (is_tw2868x(solo_dev, chip_num)) {
			solo_i2c_writebyte(solo_dev, SOLO_I2C_TW,
					       TW_CHIP_OFFSET_ADDR(chip_num),
					       TW286x_SATURATIONU_ADDR
					       (channel), u_val);
		}
		tw_writebyte(solo_dev, chip_num,
			     TW286x_SATURATIONV_ADDR(channel),
			     TW_SATURATION_ADDR(channel), u_val);

		break;

	case TW_COLOR_CONTRAST:
		tw_writebyte(solo_dev, chip_num,
			     TW286x_CONTRAST_ADDR(channel),
			     TW_CONTRAST_ADDR(channel), u_val);
		break;

	case TW_COLOR_BRIGHTNESS:
		if (is_tw2868x(solo_dev, chip_num)) {
			if (u_val == 125 || !u_val)
				u_val = 212;
			else if (u_val > 125)
				u_val -= 125;
			else
				u_val += 125;
		}
		tw_writebyte(solo_dev, chip_num,
			     TW286x_BRIGHTNESS_ADDR(channel),
			     TW_BRIGHTNESS_ADDR(channel), u_val);

		break;
	default:
		printk_once("[tw2815] Unknown color component %d\n",
			    color_comp);
		break;
	}
}

int tw2815_Get_ColorComponentValue(struct solo6010_dev *solo_dev,
				   unsigned int color_comp,
				   unsigned int channel)
{
	unsigned int chip_num;

	if (channel < 0 || channel >= solo_dev->nr_chans)
		return -1;

	/* Determine which techwell chip number this channel belongs to. */
	chip_num = channel / 4;
	/* Determine the corresponding channel for this techwell chip. */
	channel = channel % 4;

	switch (color_comp) {
	case TW_COLOR_HUE:
		return tw_readbyte(solo_dev, chip_num, TW286x_HUE_ADDR(channel),
				   TW_HUE_ADDR(channel));
	case TW_COLOR_SATURATION:
		return tw_readbyte(solo_dev, chip_num,
				   TW286x_SATURATIONU_ADDR(channel),
				   TW_SATURATION_ADDR(channel));
	case TW_COLOR_CONTRAST:
		return tw_readbyte(solo_dev, chip_num,
				   TW286x_CONTRAST_ADDR(channel),
				   TW_CONTRAST_ADDR(channel));
	case TW_COLOR_BRIGHTNESS:
		return tw_readbyte(solo_dev, chip_num,
				   TW286x_BRIGHTNESS_ADDR(channel),
				   TW_BRIGHTNESS_ADDR(channel));
	default:
		printk_once("[tw2815] Unknown color component %d\n",
			    color_comp);
	}
	return -1;
}

/*
 * For audio output volume, the output channel is only 1. In this case we
 * don't need to offset TW_CHIP_OFFSET_ADDR. The TW_CHIP_OFFSET_ADDR used
 * is the base address of the techwell chip.
 */
void tw2815_Set_AudioOutVol(struct solo6010_dev *solo_dev, unsigned int u_val)
{
	unsigned int val;
	unsigned int chip_num;

	chip_num = (solo_dev->nr_chans - 1) / 4;

	val = tw_readbyte(solo_dev, chip_num, TW286x_AUDIO_OUTPUT_VOL_ADDR,
			  TW_AUDIO_OUTPUT_VOL_ADDR);

	u_val = (val & 0x0f) | (u_val << 4);

	tw_writebyte(solo_dev, chip_num, TW286x_AUDIO_OUTPUT_VOL_ADDR,
		     TW_AUDIO_OUTPUT_VOL_ADDR, u_val);
}

void tw2815_Set_AudioInGain(struct solo6010_dev *solo_dev, unsigned int channel,
			    unsigned int u_val)
{
	unsigned int val;
	unsigned int chip_num;

	/* Determine which techwell chip number this channel belongs to */
	chip_num = channel / 4;

	/* Determine the corresponding channel for this techwell chip. We
	 * use 1-based notation so we won't be confuse on the techwell data
	 * sheet */
	channel = (channel % 4) + 1;

	val = tw_readbyte(solo_dev, chip_num,
			  TW286x_AUDIO_INPUT_GAIN_ADDR(channel),
			  TW_AUDIO_INPUT_GAIN_ADDR(channel));

	u_val = (val & ((channel % 2 == 1) ? 0xf0 : 0x0f)) |
		((channel % 2 == 1) ? u_val : u_val << 4);

	tw_writebyte(solo_dev, chip_num, TW286x_AUDIO_INPUT_GAIN_ADDR(channel),
		     TW_AUDIO_INPUT_GAIN_ADDR(channel), u_val);
}
#endif
